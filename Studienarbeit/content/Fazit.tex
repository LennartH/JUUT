\chapter{Fazit}
Am Ende bleibt die Bewertung unseres Experiments. Dass die testgetriebene Entwicklung eines Spiels in Unity zumindest teilweise möglich ist, haben wir mit unserem Prototypen gezeigt. Allerdings beschränkt sich das auf die Logik, die man bei einem Spiel auslagern kann. Um die Skripte mit in den Prozess von Test Driven Development zu nehmen, bedarf es komfortablerer Tes-Frameworks. Dass es diese bis jetzt noch nicht gibt, liegt daran, dass die meisten Spiele nicht so viel Logik haben, dass sich der Mehraufwand lohnt. Denn TDD ist anfangs ein größerer Aufwand, der sich erst bei der Fehlersuche, bei der Weiterentwicklung und Wiederverwendung des Codes auszahlt. Actionspiele, wie Egoshooter und Geschicklichkeitsspiele, die allesamt hauptsächlich auf die Interaktion des Spielers reagieren, brauchen keine komplexe Logik. Dort reicht es, dass die Objekte im Spiel auf gewisse Ereignisse reagieren. Hier macht es wenig Sinn, diese Reaktionen auszulagern und genau festzulegen. Da es bei so einem Spiel eher auf ein gutes Spielgefühl ankommt, als auf mathematische Genauigkeit. Dieses lässt sich allerdings nicht über automatische Tests bewerten. Sondern erst durch einen menschlichen Tester.\\
Sinn macht ein ausgelagerter und automatisch getesteter Code bei komplexen Spielen, die eine größere Hintergrundlogik besitzen. Dazu könnten Simulationen gehören, wie zum Beispiel SimCity, oder komplexe Rollenspiele mit großen Fähigkeitsbäumen.\\
Gerade in Spielen wie der Tower Defense aus unserem Prototypen wäre es sinnvoll manches Verhalten in den Skripten automatisch zu testen. So könnte man abfragen, ob ein Gegner wirklich von einem Projektile getroffen und ihm der entsprechende Schaden zugefügt wurde. Um so einen Fehler zu erkennen bräuchte man sonst einen menschlichen Tester, der die genauen Schaden schlecht nur einschätzen kann.\\
Es ist also in manchen Fällen sinnvoll zu testen und damit auch sinnvoll, testgetrieben zu entwickeln, da sich die Spieleentwicklung in dem Bereich nicht von gewöhnlicher Softwareentwicklung unterscheidet. Allerdings muss dafür alles im Spiel testbar sein, was mit den aktuellen Tools nicht möglich ist.\\
Unsere Erfahrungen beziehen sich hauptsächlich auf die Unity-Umgebung, allerdings sind auch die anderen großen Engines, wie zum Beispiel die \textit{Unreal-} oder \textit{Cry}-Engine nach einem ähnlichen Prinzip aufgebaut und fordern vom Programmierer nur die Erstellung von Skripten, die den Objekten in der Spielwelt zugeordnet werden.

Als Anfänger in der testgetriebenen Entwicklung ist es schwierig sich gleichzeitig noch in die Spieleentwicklung einzuarbeiten. Beides erfordert eine eher ungewohnte Art zu entwickeln, weswegen man wenigstens in einem der Bereiche bereits Erfahrungen mitbringen sollte. Ansonsten ist es schwierig beide Komplexe auf einmal zu verstehen. Durch die Erfahrungen, die wir bei der Entwicklung des Prototypen gesammelt haben, würden wir an die Aufgabe beim nächsten Mal anders herangehen. Da wir wenig bis gar keine Erfahrungen in beiden Bereichen hatten, haben wir manchmal nicht die Disziplin gehabt, der Verfahrensweise der testgetriebenen Entwicklung vollständig zu folgen, sondern sind einige Male von der Art zu entwickeln abgewichen. So geht man schnell dazu über, Code zu schreiben, den man noch nicht braucht, bzw. noch nicht getestet hat, von dem man aber glaubt, dass er irgendwann gebraucht werden könnte. Auch die Qualität der Tests leidet darunter, da man von vorhandenem Code ausgeht und Dinge nicht beachtet, die eigentlich getestet werden müssten. Außerdem kommt es vor, dass Tests nicht fehlschlagen, da der Code schon vorhanden ist und man so nicht weiß, ob der Test das richtige testet und einen beim Fehlschlagen an die richtige Stelle verweist.

Dennoch fanden wir es für uns von Vorteil, bei der Entwicklung des Prototypen testgetrieben vorzugehen. Denn auch der eigentliche negative Punkt, die Logik auslagern zu müssen, erweist sich auf lange Sicht als Vorteil, da man so strukturierten getesteten Code hat, der in sich geschlossen ist. Man kann diesen einfacher erweitern und verbessern als geskriptetes Verhalten im Spiel. Dies ist daher praktisch, da unser Prototyp eine Basis für ein späteres Spiel bildet. \\
Durch die solide und hohe Testabdeckung kann man den Code ändern, ohne zu befürchten unerkannt Probleme einzubauen. Dies ist allerdings nur möglich, da sich der Hauptteil der Logik zum großen Teil auslagern ließ. Noch besser wäre es gewesen, auch die Skripte mit Tests abgedeckt zu haben. Dies stellt so den größten Nachteil dar, denn dadurch lassen sich keine Integrationstests realisieren und Akzeptanztests, welche die Skripte beinhalten sind ebenso wenig möglich.\\
In der aktuellen Situation mit den vorhandenen Testframeworks ist eine testgetriebene Entwicklung eher aufwendig, da der zu testende Code auf jeden Fall ausgelagert werden muss, was sich nur bei komplexeren Logikanteilen lohnt. Es bietet allerdings die Möglichkeit robusten zukunftsfähigen Code zu schreiben.